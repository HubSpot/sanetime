sanetime
========

**simple, intuitive date/time manipulation**

::

    >>> time('2011-01-01','America/New_York').ms
    23208402093

    >>> (time('2012-04-15 12:30')-delta(h=30)).ms
    48238492992932

    >>> -(time()-time()).us
    84

    >>> (time('2011-01-01',tz='America/New_York') - time('2011-01-01',tz='America/Phoenix')).h
    2

    >>> str(time('2011-01-01',tz='America/New_York') + delta(h=12)).with_tz('America/Phoenix'))

If you've ever used python's datetime, date, time, calendar, timedelta, timetuple, pytz, and dateutil modules and thought: "Wow -- I love how explicit I'm being right now", then this library is not for you.

If, on the other hand, you like preserving your braincells for more important things, then you have found what you're looking for.

sanetime was written to DRY up all the common date/time manipulations we do constantly in our code while presenting the most intuitive client possible:



FAQ
===
Why is everything stored internally as microseconds?

Python's datetime gives us access to microseconds, and since milliseconds would already have us cross the 32bit integer boundary, we might as well capture everything we can and take on microseconds as well.  There are plenty of helpers on the time, tztime, and delta classes so you never have to see/manipulate the huge microsecond numbers yourself.





The Basics
==========

time
----
``time`` represents only a moment in time, internally stored as microseconds since epoch.

timetz
------
``timetz`` represents a moment in time and where that time is experienced (i.e. the timezone), internally stored as microseconds since epoch and timezone.

delta
-----
``delta`` is an amount of time, internally stored as microseconds.



Confusion
=========
Though sanetime avoids a menagerie of confusion you'd encounter without it, it does introduce one unavoidable? point of confusion.  delta's can never change based on context -- that means a delta(d=1) is always 24 hours.  So you have to be careful around daylight savings time jumps.   Whenever you use something like this: delta(d=1), you should be thinking 24 hours.  For example:



::

    >>> time('2011-01-01','America/New_York').ms
    23208402093

    >>> tztime('2012-04-15 12:30','America/New_York')-delta(d=1)

    48238492992932

    >>> -(time()-time()).us
    84

    >>> (time('2011-01-01',tz='America/New_York') - time('2011-01-01',tz='America/Phoenix')).h
    2

    >>> str(time('2011-01-01',tz='America/New_York') + delta(h=12)).with_tz('America/Phoenix'))



Requests: HTTP for Humans
=========================

Release v\ |version|. (:ref:`Installation <install>`)

Requests is an :ref:`ISC Licensed <isc>` HTTP library, written in Python, for human beings.

Python's standard **urllib2** module provides most of
the HTTP capabilities you need, but the API is thoroughly **broken**.
It was built for a different time — and a different web. It requires an *enormous* amount of work (even method overrides) to perform the simplest of tasks.

Things shouldn’t be this way. Not in Python.

::

    >>> r = requests.get('https://api.github.com', auth=('user', 'pass'))
    >>> r.status_code
    204
    >>> r.headers['content-type']
    'application/json'
    >>> r.text
    ...

See `the same code, without Requests <https://gist.github.com/973705>`_.

Requests takes all of the work out of Python HTTP/1.1 — making your integration with web services seamless. There's no need to manually add query strings to your URLs, or to form-encode your POST data. Keep-alive and HTTP connection pooling are 100%  automatic, powered by `urllib3 <https://github.com/shazow/urllib3>`_, which is embedded within Requests.


Testimonials
------------

`Heroku <http://heroku.com>`_, `PayPal <https://www.paypal.com/>`_,
`Transifex <https://www.transifex.net/>`_,
`Native Instruments <http://www.native-instruments.com/>`_, `The Washington Post <http://www.washingtonpost.com/>`_,
`Twitter, Inc <http://twitter.com>`_,
`Readability <http://readability.com>`_, and
Federal US Institutions
use Requests internally. It has been installed over 100,000 times from PyPI.

**Armin Ronacher**
    Requests is the perfect example how beautiful an API can be with the
    right level of abstraction.

**Matt DeBoard**
    I'm going to get @kennethreitz's Python requests module tattooed
    on my body, somehow. The whole thing.

**Daniel Greenfeld**
    Nuked a 1200 LOC spaghetti code library with 10 lines of code thanks to
    @kennethreitz's request library. Today has been AWESOME.

**Kenny Meyers**
    Python HTTP: When in doubt, or when not in doubt, use Requests. Beautiful,
    simple, Pythonic.


Feature Support
---------------

Requests is ready for today's web.

- International Domains and URLs
- Keep-Alive & Connection Pooling
- Sessions with Cookie Persistence
- Browser-style SSL Verification
- Basic/Digest Authentication
- Elegant Key/Value Cookies
- Automatic Decompression
- Unicode Response Bodies
- Multipart File Uploads
- Connection Timeouts
- ``.netrc`` support


Contents:

.. toctree::
   :maxdepth: 2

   pitch
   tutorial



Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`

